{"ast":null,"code":"\"use strict\";\n\nconst db = require(\"../db\");\nconst {\n  NotFoundError\n} = require(\"../expressError\");\nconst {\n  sqlForPartialUpdate\n} = require(\"../helpers/sql\");\n\n/** Related functions for companies. */\n\nclass Job {\n  /** Create a job (from data), update db, return new job data.\n   *\n   * data should be { title, salary, equity, companyHandle }\n   *\n   * Returns { id, title, salary, equity, companyHandle }\n   **/\n\n  static async create(data) {\n    const result = await db.query(`INSERT INTO jobs (title,\n                             salary,\n                             equity,\n                             company_handle)\n           VALUES ($1, $2, $3, $4)\n           RETURNING id, title, salary, equity, company_handle AS \"companyHandle\"`, [data.title, data.salary, data.equity, data.companyHandle]);\n    let job = result.rows[0];\n    return job;\n  }\n\n  /** Find all jobs (optional filter on searchFilters).\n   *\n   * searchFilters (all optional):\n   * - minSalary\n   * - hasEquity (true returns only jobs with equity > 0, other values ignored)\n   * - title (will find case-insensitive, partial matches)\n   *\n   * Returns [{ id, title, salary, equity, companyHandle, companyName }, ...]\n   * */\n\n  static async findAll() {\n    let {\n      minSalary,\n      hasEquity,\n      title\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let query = `SELECT j.id,\n                        j.title,\n                        j.salary,\n                        j.equity,\n                        j.company_handle AS \"companyHandle\",\n                        c.name AS \"companyName\"\n                 FROM jobs j \n                   LEFT JOIN companies AS c ON c.handle = j.company_handle`;\n    let whereExpressions = [];\n    let queryValues = [];\n\n    // For each possible search term, add to whereExpressions and\n    // queryValues so we can generate the right SQL\n\n    if (minSalary !== undefined) {\n      queryValues.push(minSalary);\n      whereExpressions.push(`salary >= $${queryValues.length}`);\n    }\n    if (hasEquity === true) {\n      whereExpressions.push(`equity > 0`);\n    }\n    if (title !== undefined) {\n      queryValues.push(`%${title}%`);\n      whereExpressions.push(`title ILIKE $${queryValues.length}`);\n    }\n    if (whereExpressions.length > 0) {\n      query += \" WHERE \" + whereExpressions.join(\" AND \");\n    }\n\n    // Finalize query and return results\n\n    query += \" ORDER BY title\";\n    const jobsRes = await db.query(query, queryValues);\n    return jobsRes.rows;\n  }\n\n  /** Given a job id, return data about job.\n   *\n   * Returns { id, title, salary, equity, companyHandle, company }\n   *   where company is { handle, name, description, numEmployees, logoUrl }\n   *\n   * Throws NotFoundError if not found.\n   **/\n\n  static async get(id) {\n    const jobRes = await db.query(`SELECT id,\n                  title,\n                  salary,\n                  equity,\n                  company_handle AS \"companyHandle\"\n           FROM jobs\n           WHERE id = $1`, [id]);\n    const job = jobRes.rows[0];\n    if (!job) throw new NotFoundError(`No job: ${id}`);\n    const companiesRes = await db.query(`SELECT handle,\n                  name,\n                  description,\n                  num_employees AS \"numEmployees\",\n                  logo_url AS \"logoUrl\"\n           FROM companies\n           WHERE handle = $1`, [job.companyHandle]);\n    delete job.companyHandle;\n    job.company = companiesRes.rows[0];\n    return job;\n  }\n\n  /** Update job data with `data`.\n   *\n   * This is a \"partial update\" --- it's fine if data doesn't contain\n   * all the fields; this only changes provided ones.\n   *\n   * Data can include: { title, salary, equity }\n   *\n   * Returns { id, title, salary, equity, companyHandle }\n   *\n   * Throws NotFoundError if not found.\n   */\n\n  static async update(id, data) {\n    const {\n      setCols,\n      values\n    } = sqlForPartialUpdate(data, {});\n    const idVarIdx = \"$\" + (values.length + 1);\n    const querySql = `UPDATE jobs \n                      SET ${setCols} \n                      WHERE id = ${idVarIdx} \n                      RETURNING id, \n                                title, \n                                salary, \n                                equity,\n                                company_handle AS \"companyHandle\"`;\n    const result = await db.query(querySql, [...values, id]);\n    const job = result.rows[0];\n    if (!job) throw new NotFoundError(`No job: ${id}`);\n    return job;\n  }\n\n  /** Delete given job from database; returns undefined.\n   *\n   * Throws NotFoundError if company not found.\n   **/\n\n  static async remove(id) {\n    const result = await db.query(`DELETE\n           FROM jobs\n           WHERE id = $1\n           RETURNING id`, [id]);\n    const job = result.rows[0];\n    if (!job) throw new NotFoundError(`No job: ${id}`);\n  }\n}\nmodule.exports = Job;","map":{"version":3,"names":["db","require","NotFoundError","sqlForPartialUpdate","Job","create","data","result","query","title","salary","equity","companyHandle","job","rows","findAll","minSalary","hasEquity","arguments","length","undefined","whereExpressions","queryValues","push","join","jobsRes","get","id","jobRes","companiesRes","company","update","setCols","values","idVarIdx","querySql","remove","module","exports"],"sources":["/Users/max/Desktop/Code/react-jobly/backend/models/job.js"],"sourcesContent":["\"use strict\";\n\nconst db = require(\"../db\");\nconst { NotFoundError} = require(\"../expressError\");\nconst { sqlForPartialUpdate } = require(\"../helpers/sql\");\n\n\n/** Related functions for companies. */\n\nclass Job {\n  /** Create a job (from data), update db, return new job data.\n   *\n   * data should be { title, salary, equity, companyHandle }\n   *\n   * Returns { id, title, salary, equity, companyHandle }\n   **/\n\n  static async create(data) {\n    const result = await db.query(\n          `INSERT INTO jobs (title,\n                             salary,\n                             equity,\n                             company_handle)\n           VALUES ($1, $2, $3, $4)\n           RETURNING id, title, salary, equity, company_handle AS \"companyHandle\"`,\n        [\n          data.title,\n          data.salary,\n          data.equity,\n          data.companyHandle,\n        ]);\n    let job = result.rows[0];\n\n    return job;\n  }\n\n  /** Find all jobs (optional filter on searchFilters).\n   *\n   * searchFilters (all optional):\n   * - minSalary\n   * - hasEquity (true returns only jobs with equity > 0, other values ignored)\n   * - title (will find case-insensitive, partial matches)\n   *\n   * Returns [{ id, title, salary, equity, companyHandle, companyName }, ...]\n   * */\n\n  static async findAll({ minSalary, hasEquity, title } = {}) {\n    let query = `SELECT j.id,\n                        j.title,\n                        j.salary,\n                        j.equity,\n                        j.company_handle AS \"companyHandle\",\n                        c.name AS \"companyName\"\n                 FROM jobs j \n                   LEFT JOIN companies AS c ON c.handle = j.company_handle`;\n    let whereExpressions = [];\n    let queryValues = [];\n\n    // For each possible search term, add to whereExpressions and\n    // queryValues so we can generate the right SQL\n\n    if (minSalary !== undefined) {\n      queryValues.push(minSalary);\n      whereExpressions.push(`salary >= $${queryValues.length}`);\n    }\n\n    if (hasEquity === true) {\n      whereExpressions.push(`equity > 0`);\n    }\n\n    if (title !== undefined) {\n      queryValues.push(`%${title}%`);\n      whereExpressions.push(`title ILIKE $${queryValues.length}`);\n    }\n\n    if (whereExpressions.length > 0) {\n      query += \" WHERE \" + whereExpressions.join(\" AND \");\n    }\n\n    // Finalize query and return results\n\n    query += \" ORDER BY title\";\n    const jobsRes = await db.query(query, queryValues);\n    return jobsRes.rows;\n  }\n\n  /** Given a job id, return data about job.\n   *\n   * Returns { id, title, salary, equity, companyHandle, company }\n   *   where company is { handle, name, description, numEmployees, logoUrl }\n   *\n   * Throws NotFoundError if not found.\n   **/\n\n  static async get(id) {\n    const jobRes = await db.query(\n          `SELECT id,\n                  title,\n                  salary,\n                  equity,\n                  company_handle AS \"companyHandle\"\n           FROM jobs\n           WHERE id = $1`, [id]);\n\n    const job = jobRes.rows[0];\n\n    if (!job) throw new NotFoundError(`No job: ${id}`);\n\n    const companiesRes = await db.query(\n          `SELECT handle,\n                  name,\n                  description,\n                  num_employees AS \"numEmployees\",\n                  logo_url AS \"logoUrl\"\n           FROM companies\n           WHERE handle = $1`, [job.companyHandle]);\n\n    delete job.companyHandle;\n    job.company = companiesRes.rows[0];\n\n    return job;\n  }\n\n  /** Update job data with `data`.\n   *\n   * This is a \"partial update\" --- it's fine if data doesn't contain\n   * all the fields; this only changes provided ones.\n   *\n   * Data can include: { title, salary, equity }\n   *\n   * Returns { id, title, salary, equity, companyHandle }\n   *\n   * Throws NotFoundError if not found.\n   */\n\n  static async update(id, data) {\n    const { setCols, values } = sqlForPartialUpdate(\n        data,\n        {});\n    const idVarIdx = \"$\" + (values.length + 1);\n\n    const querySql = `UPDATE jobs \n                      SET ${setCols} \n                      WHERE id = ${idVarIdx} \n                      RETURNING id, \n                                title, \n                                salary, \n                                equity,\n                                company_handle AS \"companyHandle\"`;\n    const result = await db.query(querySql, [...values, id]);\n    const job = result.rows[0];\n\n    if (!job) throw new NotFoundError(`No job: ${id}`);\n\n    return job;\n  }\n\n  /** Delete given job from database; returns undefined.\n   *\n   * Throws NotFoundError if company not found.\n   **/\n\n  static async remove(id) {\n    const result = await db.query(\n          `DELETE\n           FROM jobs\n           WHERE id = $1\n           RETURNING id`, [id]);\n    const job = result.rows[0];\n\n    if (!job) throw new NotFoundError(`No job: ${id}`);\n  }\n}\n\nmodule.exports = Job;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}